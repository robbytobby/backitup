#!/bin/bash
execute_remote_or_local () {
	#execute a command locally or remote
	local command=$1
	local return_value=''
	local exit_status=''

	if [[ $to_host == $localhost ]] ; then
		#local
		return_value=$(eval $command)
		exit_status=$?
	else
		#remote
		return_value=$(ssh -p$ssh_port $to_host $command)
		exit_status=$?
	fi

	echo -n $return_value
	return $exit_status
}

check_disk_space () {
	# built the command strings to to get percentage of inodes space and inodes
	local pipe="| tail -n1 | sed -e 's/.* \([0-9]\{1,3\}\)%.*/\1/'"
	local kb_used_command="df $bu_path $pipe"
	local inode_used_command="df -i $bu_path $pipe"
	local hd_maxused=$((100-$hd_minfree_percent))

	$verbose && message "" "checking free space on backup disk" "INFO"
	# get used space
	local hd_kb_used=$(execute_remote_or_local "$kb_used_command")
	ssh_error_check $? "check_disk_space" "$kb_used_command" "WARNING"
	# get used inodes
	local hd_inode_used=$(execute_remote_or_local "$inode_used_command")
	ssh_error_check $? "check_disk_space" "$inode_used_command" "WARNING"
	
	# compare to defined value
	if [[ $hd_kb_used -ge $hd_maxused || $hd_inode_used -ge $hd_maxused ]] ; then
		message "check_disk_space" "Not enough space left in $bu_path on $to_host for rsyncing backups!" "FATAL"
	fi
}

remount_bu_disk () {

	# check correct usage
	[ $# != 1 ] && message "remount_bu_disk" "Usage: remount_bu_disk <ro/rw> Call was: remount_bu_disk $(echo $@)" "FATAL"
	local remount_state=$1

	# get the mtab entry for the backup device
	local mtab_line=$(execute_remote_or_local "mount | grep $bu_path")
	ssh_error_check $? "remount_bu_disk" "mount | grep $bu_path" "FATAL"

	# get the current mount state
	local mount_state=$(echo $mtab_line | sed -e 's/.*(\(r[ow]\)).*/\1/')

	# return on remount rw if device is allready rw
	[[ $remount_state == 'rw' && $mount_state == 'rw' ]] &&  return 

	# get device name
	local bu_device=$(echo $mtab_line | cut -d' ' -f1)
	[ -z $bu_device ] && message "remount_bu_disk" "Could not determine backup-device on $to_host" "FATAL"

	# get file system
	local fs_type=$(echo $mtab_line | cut -d' ' -f5)
	[ -z $fs_type ] && message "remount_bu_disk" "Could not determine filesystem of $bu_device on $to_host" "FATAL"

	# built remount command
	local remount_command="mount -t $fs_type -o remount,$remount_state $bu_device $bu_path"
	
	#remount
	$verbose && message "" "remounting $bu_device on $to_host $remount_state" "INFO"
	execute_remote_or_local "$remount_command"
	ssh_error_check $? "remount_bu_disk" "$remount_command" "FATAL"
	return
}

create_backup_directory () {
	execute_remote_or_local "test -d $bu_dir"
	if [[ $? != 0 ]]; then 
		$verbose && message "" "creating needed directory $bu_dir" "INFO"
		execute_remote_or_local "mkdir -p $bu_dir" 
		ssh_error_check $? "" "mkdir -p $bu_dir" "FATAL"
	fi
}


error_check () {
	write_error "$@" 'cmd'
}
ssh_error_check () {
	write_error "$@" 'ssh-cmd'
}

message () {
	write_error -1 "$@" 'msg'
}

write_error () {
	local exit_status=$1
	local func_name=$2
	local msg=$3
	local level=$4
	local msg_type=$5

	[ $exit_status = 0 ] && return

	if [ -z $func_name ]; then
		func_name=$0
	else
		func_name=$0#$func_name
	fi

	case "$msg_type" in
		cmd)     log_msg="$level $func_name: '$msg' exited with status $exit_status" ;;
		ssh-cmd) log_msg="$level $func_name: '[ssh -p $ssh_port $to_host] $msg' exited with status $exit_status" ;;
		msg)     log_msg="$level $func_name: $msg" ;;
	esac

	echo -e $log_msg
	logger -t $log_tag $log_msg
	[ $level = "FATAL" ] && exit

}

